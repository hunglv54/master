\documentclass[a4paper,13pt,oneside,openany]{book}
\usepackage[utf8]{vietnam}
\usepackage[document]{ragged2e}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{graphicx}
\linespread{1.3}
\pagestyle{empty}
\usepackage[ruled,vlined,linesnumbered,algochapter]{algorithm2e}
\newenvironment{megaalgorithm}[1][htb]
{\renewcommand{\algorithmcfname}{Thuật toán}% Update algorithm name
	\begin{algorithm}[#1]%
}{\end{algorithm}}
\newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line
\begin{document}
	\begin{center}
		\textbf{\large Luận văn thạc sĩ}
	\end{center}
	\begin{flushleft}
	\chapter{Giới thiệu}
	\chapter{Kiến thức cơ sở}
		\section{Dạng đặc tả sử dụng hệ chuyển trạng thái được gắn nhãn}
		\justify
		\textbf{\textit{Định nghĩa 2.1}}: Hệ chuyển trạng thái gắn nhãn (Labeled Transition System - LTS) được định nghĩa là một bộ có thứ tự gồm 4 thành phần: $M = <Q, \Sigma, \delta, q_{0}>$ [2]\\
		Trong đó:\\
		\begin{itemize}
			\item Q = $\{q_{0}, q_{1}, ..., q_{n-1}, q_{n}\}$ là tập các trạng thái,
			\item $\Sigma = \{w_{0}, w_{1}, ..., w_{n-2}, w_{n-1}\}$ là tập các sự kiện,
			\item $\delta \subseteq$ Q x $\Sigma$ x Q là hàm chuyển trạng thái, và
			\item $q_{0} \subseteq Q$ là trạng thái khởi tạo.\\
		\end{itemize}
		Ta kí hiệu $q_i \overset{w_i}{\longrightarrow} q_{j}$ nếu và chỉ nếu có một sự kiện $w_i$ chuyển hệ thống từ trạng thái $q_i$ sang trạng thái $q_j$, khi đó $(q_i, w_i, q_j) \in \delta$. Điều này có nghĩa khi một hệ thống đang ở trạng thái $q_i$, nếu có một sự kiện $w_i$ xảy ra thì hệ thống sẽ chuyển sang trạng thái $q_j$. Tương tự, khi hệ thống đang ở trạng thái $q_j$ nếu có một hành động $w_k$ xảy ra thì hệ thống sẽ chuyển sang trạng thái $q_k$. Như vậy, chuỗi hai hành động  $q_i \overset{w_i}{\longrightarrow} q_j$,  $q_j \overset{w_k}{\longrightarrow} q_k$ có thể chuyển hệ thống từ trạng thái $q_i$ sang trạng thái $q_k$. Khi đó, ta có thể kí hiệu  $q_i \overset{w_iw_k}{\longrightarrow} q_{k}$.\\
		\textbf{Ví dụ 2.1}: Ví dụ về một hệ thống chuyển trạng thái được gắn nhãn.\\
		\begin{figure}[h]
			\centering
			\includegraphics[scale=0.5]{LTS1.png}
			\caption{Một hệ thống chuyển trạng thái được gán nhãn.}
			\label{fig:LTS1}
		\end{figure}
		Trên hình \ref{fig:LTS1} là một ví dụ về một LTS $M = <Q, \Sigma, \delta, q_{0}>$, trong đó:
		\begin{itemize}
			\item Q = $\{q_0, q_1, q_2, q_3\}$,
			\item $\Sigma = \{openWindow, start, stop, closeWindow\}$,
			\item $\delta = \{(q_0, openWindow, q_1), (q_1, start, q_2), (q_2, stop, q_3), (q_3, closeWindow, q_0)\}$, và
			\item $q_0$ là trạng thái khởi tạo.
		\end{itemize}
		\textbf{\textit{Định nghĩa 2.2}}: Kích thước của một tập hợp [1].\\
		Kích thước của một tập hơp $Q = \{q_0, q_1, ..., q_{n-1}, q_n\}$ là số phần tử của tập hợp Q, kí hiệu là |Q|.\\
		\textbf{Ví dụ 2.2}: Với LTS được cho bởi hình \ref{fig:LTS1}, tập các trạng thái $Q = \{q_0, q_1, q_2, q_3\}$ nên |Q| = 4.\\
		\textbf{\textit{Định nghĩa 2.3}}: Kích thước của một LTS [3].\\
		Kích thước của một LTS $M = <Q, \Sigma, \delta, q_{0}>$ là số trạng thái của M, kí hiệu là |M|, trong đó |M| = |Q|.
		\textbf{Ví dụ 2.3}: Với LTS được cho bởi hình \ref{fig:LTS1}, kích thước của LTS đó là |M| = |Q| = 4.\\
		\textbf{\textit{Định nghĩa 2.4}}: Vết của LTS.\\
		Vết của một LTS $M = <Q, \Sigma, \delta, q_{0}>$ là một chuỗi hữu hạn các sự kiện có dạng $\sigma = w_0w_1...w_k$ với $w_k \in \Sigma$ và $0 \leq k \leq n$ sao cho tồn tại trạng thái $q_i \in Q$ mà $q_0 \overset{w}{\longrightarrow} q_{i}$\\
		Như vậy, vết $\sigma$ của LTS M là một chuỗi các sự kiện có thể quan sát được mà M có thể thực hiện được từ trạng thái khởi tạo $q_0$.\\
		\textbf{Ví dụ 2.4}: Vết của LTS.\\
		\begin{figure}[h]
			\centering
			\includegraphics[scale=0.5]{LTS1.png}
			\caption{Minh họa vết của LTS.}
			\label{fig:LTS2}
		\end{figure}
		Hình \ref{fig:LTS2} minh là một LTS $M = <Q, \Sigma, \delta, q_{0}>$, trong đó:
		\begin{itemize}
			\item Q = $\{q_0, q_1, q_2, q_3\}$,
			\item $\Sigma = \{openWindow, start, stop, closeWindow\}$,
			\item $\delta = \{(q_0, openWindow, q_1), (q_1, start, q_2), (q_2, stop, q_3), (q_3, closeWindow, q_0)\}$, và
			\item $q_0$ là trạng thái khởi tạo.
		\end{itemize}
		Ta thấy, chuỗi các hành động $openWindow$ $start$ $stop$ là một vết của M, bởi vì tại trạng thái khởi tạo $q_0$, khi sự kiện $openWindow$ xảy ra, hệ thống chuyển sang trạng thái $q_1$, tiếp tục xảy ra sự kiện $start$ hệ thống chuyển sang trạng thái $q_2$, khi xảy ra sự kiện $stop$ hệ thống chuyển sang trạng thái $q_3$. Chuỗi các hành động $openWindow$ $start$ $stop$ chuyển hệ thông từ trạng thái khởi tạo $q_0$ sang trạng thái $q_3 \in Q$ nên chuỗi các hành động  $openWindow$ $start$ $stop$ là một vết của LTS. Tương tự, chuỗi các hành động $openWindow$, $openWindow$ $start$, $openWindow$ $star$ $stop$ $closeWindow$, $openWindow$ $star$ $stop$ $closeWindow$ $openWindow$, ... đều là vết của M.\\
		\textbf{\textit{Định nghĩa 2.5}}: Ngôn ngữ của LTS.\\
		Ngôn ngữ của LTS M kí hiệu là L(M) được định nghĩa như sau:\\
		$L(M) = \{\alpha \ | \ \alpha$ là một vết của $M\}$\\
		\textbf{Ví dụ 2.5}: Ví dụ về ngôn ngữ của LTS.\\
		Với LTS M như ở hình \ref{fig:LTS2}, ngôn ngữ của M là:\\
		$L(M) = \{openWindow, onpenWindow\ start, openWindow \ start \ stop, ...\}$
		
		\section{Dạng đặc tả sử dụng hàm logic (Bool)}
		\textbf{\textit{Định nghĩa 2.6}}: Hàm logic [1].\\
		B = $\{$T, F$\}$ là miền giá trị logic. Với X là tập hợp các biến logic, một hàm logic $\theta(X)$ được định nghĩa: $\theta(X): B^{|X|} \rightarrow B$.\\
		\textbf{Ví dụ 2.6}: Với X là tập hợp gồm 3 phần tử, X = $\{$x, y, z$\}$ với x, y, z $\in$ B, cho hàm logic $\theta(x, y, z) = x \land y \lor z$ ta được một ánh xạ $\theta(X): B^3 \rightarrow B $.\\
		\textbf{\textit{Định nghĩa 2.7}}: Phép gán [1].\\
		Với X là tập hợp các biến logic, phép gán $\upsilon$ được đinh nghĩa: $\upsilon$: X $\rightarrow$ B.\\
		\textbf{Ví dụ 2.7}: Với X là tập hợp gồm 3 phần tử, X = $\{x, y, z\}$ với x, y, z $\in$ B, $\upsilon(x)$ = T, $\upsilon(x)$ = F, $\upsilon(y)$ = T, $\upsilon(y)$ = F, $\upsilon(z)$ = T và $\upsilon(z)$ = F là các phép gán trên tập X.\\
		\textbf{\textit{Định nghĩa 2.8}}: Phép gán hàm [1].\\
		Với $\phi(X)$ là hàm môt logic trên tập X, $\upsilon$ là một phép gán trên tập X, phép gán hàm kí hiệu $\phi[\upsilon]$ là kết quả thu được khi thay các phần tử x $\in$ X bởi $\upsilon(x)$.
		Với $X$ và $X'$ là các tập biến logic, $\psi(X, X')$ là hàm logic trên hai tập X và X', với $\upsilon(X)$ và $\upsilon(X')$ lần lượt là các phép gán trên tập X và X', kí hiệu $\psi[\upsilon, \upsilon']$ là kết quả thu được khi thay một cách tương ứng $x \in X$ bởi $\upsilon(X)$ và $x' \in X'$ bởi $\upsilon'(X')$.\\
		\textbf{Ví dụ 2.8}: Với X = $\{x\}$, X' = $\{x'\}$ là tập hợp các biến logic, $\phi(x) = \overline{x}$ là một hàm logic trên tập X. Nếu $\upsilon(x)$ = T thì $\phi[\upsilon]$ = F và nếu $\upsilon(x)$ = F thì $\phi[\upsilon]$ = T. Với $\psi(x, x') = x \lor x'$ là một hàm logic trên tập X và X', nếu $\upsilon(x)$ = T, $\upsilon(x')$ = F thì $\psi[\upsilon, \upsilon']$ = T $\lor$ F = T.\\
		\textbf{\textit{Định nghĩa 2.9}}: Dạng đặc tả sử dụng hàm logic.\\
		Dạng đặc tả sử dụng hàm logic là một bộ có thứ tự gồm 4 phần tử:\\
		$N = <X, E, \tau(X, E, X'), \iota(X)>$\\
		Trong đó:\\
		\begin{itemize}
			\item X là tập các biến logic dùng để biểu diễn các trạng thái của hệ thống. X = $\{x_0, x_1, ..., x_n\}$,
			\item E là tập các biến logic dùng để biểu diễn các hành vi của hệ thống. E = $\{e_0, e_1, ..., e_{n-1}, e_n\}$,
			\item $\tau \subseteq X \land E \land X$ là hàm logic biểu diễn việc chuyển trạng thái của hệ thống, và
			\item $\iota(X)$ là hàm logic dùng để biểu diễn các trạng thái khởi tạo của hệ thống.
		\end{itemize}
		\textbf{Ví dụ 2.9}: Với dạng đặc tả sử dụng hàm logic $N = <X, E, \tau(X, E, X'), \iota(X)>$. Trong đó:\\
		\begin{itemize}
			\item X = $\{x_1, x_2, x_5, x_6\}$,
			\item E = $\{x_3, x_4\}$
			\item $\tau(X, E, X')$ = $\{$($\overline{x}_1 \land \overline{x}_2 \land \overline{x}_3 \land \overline{x}_4 \land \overline{x}_5 \land x_6$), ($\overline{x}_1\land\overline{x}_2\land x_3\land \overline{x}_4\land x_5\land\overline{x}_6$),\\
			$\}$
		\end{itemize}
		
		Với $\tau(x, e, x')$ là hàm logic biểu diễn việc chuyển trạng thái của hệ thống, xét một chuyển trạng thái thứ i bất kì, khi $\tau[x_i, e_i, x_{i+1}]$ = True là một bộ 3 các phép gán cho các hàm mã hóa $x_i, e_i, x_{i+1}$ thì $\upsilon[x_i]$ = True, $\upsilon[e_i]$ = True và $\upsilon[x_{i+1}]$ = True. Chuỗi hữu hạn các phép gán cho hàm mã hóa các sự kiện $\xi = \upsilon(e_0)\upsilon(e_1)...\upsilon(e_{n-1})$ được gọi là vết của N. Khi đó, $\iota[\upsilon^0]$ = True và $\tau[\upsilon^i,  \upsilon^{i+1}]$ = True với $\forall i: 0 \leq i < n$.\\
				Tập các vết của N được gọi là ngôn ngữ của N, kí hiệu là L(N), $L(N) = \{\xi\ |\ \xi$ là một vết của N\}\\

			\subsection{Khái niệm về bảng ánh xạ}
				Bảng ánh xạ (mapping) là một bảng dùng để lưu lại các ánh xạ khi chuyển đổi từ dạng đặc tả sử dụng LTS sang dạng đặc tả sử dụng hàm logic và ngược lại,\\
				Gọi Map là kí hiệu của bảng ánh xạ. Với một LTS $M = <Q, \Sigma, \delta, q_{0}>$ và một dạng đặc tả sử dụng hàm logic $N = <X, E, \tau(x, e, x'), \iota(x)>$. Ta định nghĩa:\\
				Map = $\{Q = Q_1 \cup Q_2, \Sigma, \delta(q, e, q'), X = X_1 \cup X_2, E, \tau(x, e, x')\}$\\
				Trong đó:\\
				\begin{itemize}
					\item $Q = Q_1 \cup Q_2$ là tập các trang thái của LTS. Với $Q_1$ là tập các trạng thái đầu vào (from), $Q_2$ là tập các trạng thái đầu ra (to).\\
					\item $\Sigma$ là tập các sự kiện của LTS,
					\item $\delta(q, e, q')$ là hàm chuyển trạng thái, $X = X_1 \cup X_2$ là tập các biến logic dùng để biểu diễn tập các trạng thái. Với $X_1$, $X_2$ lần lượt là dạng đặc tả sử dụng hàm logic của tập các trạng thái đầu vào và đầu ra,
					\item E là tập các biến logic dùng để biểu diễn các hành vì của hệ thống, E = $\{e_0, e_1, ..., e_{n-1}\}$, và
					\item $\tau(x, e, x')$ là hàm logic biểu diễn việc chuyển trạng thái của hệ thống.\\
				\end{itemize}
				Ví dụ: Với một LTS như hình vẽ. Ta có tập các trạng thái $Q = \{a, b, c\}$. Với tập các trạng thái đầu vào $Q_{1} = \{a, b, c\}$, tập trạng thái đầu ra $Q_{2} = \{b, c, a\}$ và tập các sự kiện $E = \{send, out, ack\}$.\\
			
				Ta có bảng ánh xạ:
				\begin{table}[!ht]
					\centering
					\renewcommand{\arraystretch}{1.25}
					\begin{tabular}{|c|c|c|c|c|}
						\hline
						$Q_1$ & a & b & c\\
						\hline
						$X_1$ & $x_0x_1$ & $x_0\overline x_1$& $\overline x_0x_1$\\
						\hline
					\end{tabular}
					\begin{tabular}{|c|c|c|c|c|}
						\hline
						$Q_2$ & a & b & c\\
						\hline
						$X_2$ & $x_4x_5$ & $x_4\overline x_5$& $\overline x_4x_5$\\
						\hline
					\end{tabular}
				\end{table}
				\begin{table}[!ht]
					\centering
					\renewcommand{\arraystretch}{1.25}
					\begin{tabular}{|c|c|c|c|}
						\hline
						$\Sigma$ & send & out & ack\\
						\hline
						E & $x_2x_3$ & $x_2\overline x_3$& $\overline x_2x_3$ \\
						\hline
					\end{tabular}
				\end{table}
				\begin{table}[!ht]
					\centering
					\renewcommand{\arraystretch}{1.25}
					\begin{tabular}{|c|c|c|c|}
						\hline
						$\delta(q, e, q')$ & $\delta(a, send, b)$ & $\delta(b, out, c)$ & $\delta(c, ack, a)$\\
						\hline
						$\tau(x, e, x')$ & $x_0x_1 \land x_2x_3 \land x_4\overline x_5$ & $x_0\overline x_1 \land x_2 \overline x_3 \land x_4 \overline x_5$ & $\overline x_0 x_1 \land \overline x_2 x_3 \land x_4x_5$ \\
						\hline
					\end{tabular}
					\caption{Ví dụ về bảng ánh xạ}
				\end{table}
	\chapter{Phương pháp chuyển đổi}				
		\section{Thuật toán}
		Đầu vào (Input): Một hệ chuyển trạng thái gắn nhãn.\\
		Đầu ra (Output): Dạng đặc tả sử dụng hàm logic và bảng ánh xạ.\\
		Thuật toán chia làm 4 bước:
		
		\begin{itemize}
			\item Bước 1: Mã hóa tập các trạng thái đầu vào $Q_1$ - Thuật toán 1.
			\item Bước 2: Mã hóa tập các trạng thái đầu ra $Q_2$ - Thuật toán 1.
			\item Bước 3: Mã hóa tập các sự kiện - Thuật toán 2.
			\item Bước 4: Mã hóa tập các chuyển trạng thái - Thuật toán 3.
		\end{itemize}
		
		\subsection{Thuật toán mã hóa tập các trạng thái}
		\begin{megaalgorithm}[H]
			\SetKwInOut{Input}{Đầu vào}
			\SetKwInOut{Output}{Đầu ra}
			\SetAlgoLined
			\DontPrintSemicolon
			\Input{Tập các trạng thái Q.}
			\Output{Dạng mã hóa của tập các trạng thái.}
				
			\For{mỗi trạng thái $q_{i}$ trong tập các trạng thái Q}{
				$x$ = True\;
				k = Thứ tự của $q_i$ trong Q\;
				Chuyển k sang số nhị phân với độ dài $[log_2(|Q|)] + 1$ bit\;
				\For{mỗi bit $x_i$ trong chuỗi nhị phân biểu diễn k} {
					\uIf{$x_i$ = 1} {
						Biểu diễn $x_i$ dưới dạng $x_i$\;
					}
					\Else {
						Biểu diễn $x_i$ dưới dạng $\overline x_i$\;
					}
					$x = \overset{n}{\underset{i=1}{\lor}} \{x_i \land x\}$
				}
				Lưu $x$ vào bảng ánh xạ ứng với vị trí của $q_i$.
			}
			\caption{Mã hóa tập các trạng thái}
		\end{megaalgorithm}
		
		Với Q là tập các trạng thái $Q = \{q_0, q_1, ..., q_{n-1}, q_n\}$. Số biến logic cần dùng để mã hóa tập các trạng thái $Q$ là $[log_{2}n] + 1$ = m. Gọi $x_{1}, x_{2}, ..., x_{m}$ là chuỗi biến logic dùng để mã hóa các trạng thái của $Q$. Mỗi trạng thái $q_i$ trong $Q$ sẽ được biểu diễn dưới dạng $x_{1}\land x_{2}\land...\land x_{m}$.\\
		Xét trạng thái bất kì $q_k$ trong tập $Q$, theo bước (2) ta xác định được thứ tự của $q_k$ trong tập $Q$ là k, theo bước (3) thì k sẽ biểu diễn dưới dạng số nhị phân $[log_{2}n] + 1$ bit. Theo bước (4)-(10) chúng ta sẽ mã hóa được trạng thái $q_k$. Thêm vào đó, theo bước (11) dạng biểu diễn của trạng thái $q_k$ sẽ được lưu vào trong bảng ánh xạ. Mục đích của việc lưu vào bảng ánh xạ là để dùng cho việc chuyển ngược lại từ dạng đặc tả sử dụng hàm logic sang dạng đặc tả sử dụng LTS. Bởi vì, thứ tự của mỗi trạng thái trong $q_k$ là duy nhất nên số nhị phân biểu diễn thứ tự của trạng thái $q_k$ cũng sẽ là duy nhất, vì thế dạng mã của trạng thái $q_k$ là duy nhất.\\
		Một cách tương tự cho các trạng thái khác trong $Q$, chúng ta sẽ mã hóa cho tất cả các trạng thái. Thêm vào đó, sau khi mã hóa, các thông tin về trạng thái và dạng mã hóa của các trạng thái này đều được lưu vào bảng ánh xạ, nhằm mục đích sử dụng cho việc chuyển đổi ngược lại từ dạng đặc tả sử dụng hàm logic sang dạng đặc tả sử dụng LTS.\\
		\textbf{Độ phức tạp:} Độ phức tạp của thuật toán là O(n), trong đó n là kích thước của tập các trạng thái cần mã hóa.\\	
		
		\subsection{Thuật toán mã hóa tập các sự kiện}
		\begin{megaalgorithm}[H]
			\SetKwInOut{Input}{Đầu vào}
			\SetKwInOut{Output}{Đầu ra}
			\SetAlgoLined
			\DontPrintSemicolon
			\Input{Tập các sự kiện $\Sigma$.}
			\Output{Dạng mã hóa của tập các sự kiện.}
				
			\For{mỗi sự kiện $w_i$ trong tập các sự kiện $\Sigma$}{
				$e$ = True\;
				k = Thứ tự của $w_i$ trong $\Sigma$\;
				Chuyển k sang số nhị phân với độ dài $[log_2(|\Sigma|)] + 1$ bit\;
				\For{mỗi bit $x_i$ trong chuỗi nhị phân biểu diễn k} {
					\uIf{$x_i$ = 1} {
						Biểu diễn $x_i$ dưới dạng $x_i$\;
					}
					\Else {
						Biểu diễn $x_i$ dưới dạng $\overline x_i$\;
					}
					$e = \overset{n}{\underset{i=1}{\lor}} \{x_i \land e\}$
				}
				Lưu $e$ vào bảng ánh xạ ứng với vị trí của $w_i$
			}
			\caption{Mã hóa tập các sự kiện}
		\end{megaalgorithm}
		
		\subsection{Thuật toán mã hóa tập các truyển trạng thái}
		\begin{megaalgorithm}[H]
			\SetKwInOut{Input}{Đầu vào}
			\SetKwInOut{Output}{Đầu ra}
			\SetAlgoLined
			\DontPrintSemicolon
			\Input{Tập các chuyển trạng thái của LTS.}
			\Output{Tập các chuyển trạng thái được biểu diễn bằng dạng đặc tả sử dụng hàm logic.}
				
			\For{mỗi chuyển trạng thái được biểu diễn $\delta(q, w, q')$}{
				Lấy dạng biểu diễn của $q$ từ bảng ánh xạ\;
				Lấy dạng biểu diễn của $w$ từ bảng ánh xạ\;
				Lấy dạng biểu diễn của $q'$ từ bảng ánh xạ\;
				Biểu diễn chuyển trạng thái dươi dạng: $x_i\land e_i \land x_{i+1}$
			}
			\Return $\tau = \overset{n}{\underset{i=1}{\lor}} \{x_i \land e_i \land x_{i+1}\}$
				
			\caption{Mã hóa tập các chuyển trạng thái}
		\end{megaalgorithm}
		\section{Mã hóa các chuyển trạng thái}
		Một chuyển trạng thái (Transition) được biểu diễn là một bộ 3 $\delta = Q_{1} \times \Sigma \times Q_{2}$ hay $\delta = q_{i} \land e_i \land q_{i+1}$ với $\forall q_{i} \in Q_{1}$, $\forall e_{i} \in \Sigma$\\ và $\forall q_{i+1} \in Q_{2}$
		Theo bước (2) trạng thái đầu vào from = $q_{i}$ sẽ được chuyển sang dạng đặc tả sử dụng hàm logic. Theo bước (3) sự kiện $e_i$ sẽ được chuyển sang dạng đặc tả sử dụng hàm logic. Theo bước (4) trạng thái đầu ra to = $q_{i+1}$ sẽ được chuyển sang dạng đặc tả sử dụng hàm logic. Sau bước (5), mỗi chuyển đổi trạng thái sẽ được biểu diễn dưới dạng $x_{i} \land e_i \land x_{i+1}$.\\
		
		Với thuật toán mã hóa 3, đầu ra của thuật toán này là $\tau = \lor_{i=1}^n \{x_i \land e_i \land x_{i+1}\}$. Xét $\tau_i = \{x_i \land e_i \land x_{i+1}\}$, $\tau_j = \{x_j \land e_j \land x_{j+1}\}$ với j = i + 1, ta có $\psi [\tau_i]$ = True thì $\upsilon[x_i]$ = True, $\upsilon[x_{i+1}]$ = True, $\upsilon[e_i]$ = True, $\psi [\tau_j]$ = True thì $\upsilon[x_j]$ = True, $\upsilon[x_{j+1}]$ = True, $\upsilon[e_j]$ = True, khi đó $\tau [e_i, e_j]$ = True.

		\section{Chứng minh}
		Để chứng minh ngôn ngữ của dạng đặc tả được biểu diễn bằng LTS tương đương với ngôn ngữ của dạng đặc tả sử dụng hàm logic, chúng ta cần chứng minh 2 mệnh đề:
		\begin{itemize}
			\item Mệnh đề 1: Ngôn ngữ của dạng đặc tả hệ thống biểu diễn bằng LTS sau khi chuyển đổi sang dạng đặc tả biểu diễn bằng hàm logic được đoán nhận bởi ngôn ngữ của dạng đặc tả được biểu diễn bởi hàm logic. (1)\\
			\item Mệnh đề 2: Ngôn ngữ của dạng đặc tả được chuyển đổi từ hàm logic sau khi chuyển đổi sang dạng đặc tả biểu diễn bằng LTS được đoán nhận bởi ngôn ngữ của LTS.
		\end{itemize}
		\textbf{Chứng minh mệnh đề 1}:\\
		Gọi $\alpha = w_0w_1...w_{n-1}$ là một dẫn xuất bất kì trong ngôn ngữ L, áp dụng thuật toán mã hóa như đã trình bày ở 4.1, ta được một dẫn xuất $\alpha' = e_0e_1...e_{n-2}e_{n-1}$ và một bảng mapping A, ta sẽ chứng minh $\alpha'$ cũng được đoán nhận với ngôn ngữ của dạng đặc tả được biểu diễn bởi hàm logic.\\
		Thật vậy, vì $\alpha'$ là đầu ra của $\alpha$ trong thuật toán mã hóa, mà $w_{0}$ là sự kiện đầu tiên của LTS nên $\iota[e_0]$ = True. Mặt khác, $\delta(q_i, w_i) = q_{i+1}$, $\delta(q_{i+1}, w_{i+1}) = q_{i+2}$ với $\forall i: 0 \leq i < n$ nên $\tau[x_i, e_i, x_{i+1}]$ = True và $\tau[x_{i+1}, e_{i+1}, x_{i+2}]$ = True, $\tau[e_i, e_{i+1}]$ = True. Do đó, $\alpha'$ là một vết của N.\\
		\textbf{Chứng minh mệnh đề 2}:\\
		Gọi $\xi = e_0e_1...e_{n-1}$ là một vết của N. Gọi A là bảng ánh xạ lưu các ánh xạ khi chuyển đổi từ dạng đặc tả sử dụng LTS sang dạng đặc tả sử dụng hàm logic. Áp dụng thuật toán mã hóa đã trình bày ở 4.1, ta được một chuỗi $\xi' = w_0w_1...w_{n-2}w_{n-1}$. Ta sẽ chứng minh $\xi'$ được đoán nhận bởi LTS. Thật vậy, với $e_0$ là dạng biểu diễn cho của sự kiện thứ 0 của dạng đặc tả sử dụng hàm logic, khi đó $\iota[e_0]$ = True, dựa vào bảng ánh xạ $e_0$ tương ứng với  $w_{0}$ của dạng biểu diễn diễn sử dụng LTS do đó $w_{0}$ là sự kiện thứ 0 hay sự kiện đầu tiên của LTS. Vì $\xi$ là một vết của N nên $\tau[e_i,e_{i+1}] = T$ với $\forall i: 0 \leq i < n$, vì thế $\tau[x_i, e_i, x_{i+1}]$ = True, $\tau[x_{i+1}, e_{i+1}, x_{i+2}]$ = True. Dựa vào bảng ánh xạ, $x_i$ ứng với $q_i$, $x_{i+1}$ ứng với $q_{i+1}$, $x_{i+2}$ ứng với $q_{i+2}$, $e_i$ ứng với $w_i$, $e_{i+1}$ ứng với $w_{i+1}$ trong dạng đặc tả sử dụng LTS, do đó $\delta(q_{i}, w_{i}) = q_{i+1}$, $\delta(q_{i+1}, w_{i+1}) = q_{i+2}$ với $\forall i: 0 \leq i < n$, $\delta$ là hàm chuyển trạng thái của LTS. Ta thấy, $\xi'$ hoàn toàn được đoán nhận bởi ngôn ngữ của LTS.
	\chapter{Ví dụ về việc chuyển đổi giữa các dạng đặc tả}
	\end{flushleft}
\begin{thebibliography}{9}
	\bibitem{latexcompanion} 
	Yu-Fang Chen, Edmund M. Clarke, Azadeh Farzan, Ming-Hsien Tsai,
	Yih-Kuen Tsay, and Bow-Yaw Wang, \textit{Automated Assume-Guarantee Reasoning
		through Implicit Learning}. 
	Addison-Wesley, Reading, Massachusetts, 1993.
	\bibitem{latexcompanion1}
	Pham Ngoc Hung, \textit{Assume-Guarantee Verification of Evolving Component-Based Software}.
	Japan Advanced Institute of Science and Technology in partial fulfillment of the requirements for the degree of Doctor of Philosophy, September, 2009.
	\bibitem{latexcompanion2}
	P. N. Hung, N. V.  Ha, T. Aoki and T. Katayama, \textit{On Optimization of Minimized Assumption Generation Method for Component-based Software Verification}
	IEICE Trans. on Fundamentals, Special Issue on Software Reliability Engineering, Vol. E95-A, No.9, pp. 1451-1460, Sep. 2012.
\end{thebibliography}
\end{document}