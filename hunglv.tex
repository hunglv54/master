\documentclass[a4paper,13pt,oneside,openany]{book}
\usepackage[utf8]{vietnam}
\usepackage[document]{ragged2e}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{graphicx}
\linespread{1.3}
\pagestyle{empty}
\usepackage[ruled,vlined,linesnumbered,algochapter]{algorithm2e}
\newenvironment{megaalgorithm}[1][htb]
{\renewcommand{\algorithmcfname}{Thuật toán}% Update algorithm name
	\begin{algorithm}[#1]%
}{\end{algorithm}}
\newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line
\begin{document}
	\begin{center}
		\textbf{\large Luận văn thạc sĩ}
	\end{center}
	\begin{flushleft}
	\chapter{Giới thiệu}
	\chapter{Kiến thức cơ sở}
		\section{Dạng đặc tả sử dụng hệ chuyển trạng thái được gắn nhãn}
		\justify
		\textbf{\textit{Định nghĩa 2.1}}: Hệ chuyển trạng thái được gắn nhãn (Labelled Transition System - LTS [2])\\
		Một LTS là một bộ có thứ tự gồm 4 thành phần: M = $\langle$ Q, $\Sigma, \delta, q_{0}$ $\rangle$\\
		Trong đó:
		\begin{itemize}
			\item Q = $\{q_{0}, q_{1}, ..., q_{n}\}$ là tập các trạng thái,
			\item $\Sigma = \{w_{0}, w_{1}, ..., w_n\}$ là tập các sự kiện,
			\item $\delta \subseteq$ Q x $\Sigma$ x Q là hàm chuyển trạng thái, và
			\item $q_{0} \subseteq \textrm{Q}$ là trạng thái khởi tạo.
		\end{itemize}
		Ta kí hiệu $q_i \overset{w_i}{\longrightarrow} q_{j}$ nếu và chỉ nếu có một sự kiện $w_i$ chuyển hệ thống từ trạng thái $q_i$ sang trạng thái $q_j$, khi đó $(q_i, w_i, q_j) \in \delta$. Điều này có nghĩa khi một hệ thống đang ở trạng thái $q_i$, nếu có một sự kiện $w_i$ xảy ra thì hệ thống sẽ chuyển sang trạng thái $q_j$. Tương tự, khi hệ thống đang ở trạng thái $q_j$ nếu có một hành động $w_k$ xảy ra thì hệ thống sẽ chuyển sang trạng thái $q_k$. Như vậy, chuỗi hai hành động  $q_i \overset{w_i}{\longrightarrow} q_j$,  $q_j \overset{w_k}{\longrightarrow} q_k$ có thể chuyển hệ thống từ trạng thái $q_i$ sang trạng thái $q_k$. Khi đó, ta có thể kí hiệu  $q_i \overset{w_iw_k}{\longrightarrow} q_{k}$.\\
		\textbf{Ví dụ 2.1}: Ví dụ về một hệ thống chuyển trạng thái được gắn nhãn.\\
		\begin{figure}[h]
			\centering
			\includegraphics[scale=0.5]{LTS1.png}
			\caption{Một hệ thống chuyển trạng thái được gán nhãn.}
			\label{fig:LTS1}
		\end{figure}
		Trên hình \ref{fig:LTS1} là một ví dụ về một LTS M = $\langle$ Q, $\Sigma, \delta, q_{0}$ $\rangle$, trong đó:
		\begin{itemize}
			\item Q = $\{q_0, q_1, q_2, q_3\}$,
			\item $\Sigma = \{openWindow, start, stop, closeWindow\}$,
			\item $\delta = \{(q_0, openWindow, q_1), (q_1, start, q_2), (q_2, stop, q_3), (q_3, closeWindow, q_0)\}$, và
			\item $q_0$ là trạng thái khởi tạo.
		\end{itemize}
		\textbf{\textit{Định nghĩa 2.2}}: Kích thước của một tập hợp [1].\\
		Kích thước của một tập hơp Q = $\{q_0, q_1, ..., q_n\}$ là số phần tử của tập hợp Q, kí hiệu là |Q|.\\
		\textbf{Ví dụ 2.2}: Với LTS được cho bởi hình \ref{fig:LTS1}, tập các trạng thái Q = $\{q_0, q_1, q_2, q_3\}$ nên |Q| = 4.\\
		\textbf{\textit{Định nghĩa 2.3}}: Kích thước của một LTS [3].\\
		Kích thước của một LTS M = $\langle$ Q, $\Sigma, \delta, q_{0}$ $\rangle$ là số trạng thái của M, kí hiệu là |M|, trong đó |M| = |Q|.\\
		\textbf{Ví dụ 2.3}: Với LTS được cho bởi hình \ref{fig:LTS1}, kích thước của LTS đó là |M| = |Q| = 4.\\
		\textbf{\textit{Định nghĩa 2.4}}: Vết của LTS.\\
		Vết của một LTS M = $\langle$ Q, $\Sigma, \delta, q_{0}$ $\rangle$ là một chuỗi hữu hạn các sự kiện có dạng $\sigma = w_0w_1...w_k$ với $w_k \in \Sigma$ và $0 \leq k \leq n$ sao cho tồn tại trạng thái $q_i \in$ Q mà $q_0 \overset{\sigma}{\longrightarrow} q_{i}$.\\
		Như vậy, vết $\sigma$ của LTS M là một chuỗi các sự kiện có thể quan sát được mà M có thể thực hiện được từ trạng thái khởi tạo $q_0$.\\
		\textbf{Ví dụ 2.4}: Vết của LTS.\\
		\begin{figure}[h]
			\centering
			\includegraphics[scale=0.5]{LTS1.png}
			\caption{Minh họa vết của LTS.}
			\label{fig:LTS2}
		\end{figure}
		Hình \ref{fig:LTS2} minh họa một LTS M = $\langle$ Q, $\Sigma, \delta, q_{0}$ $\rangle$, trong đó:
		\begin{itemize}
			\item Q = $\{q_0, q_1, q_2, q_3\}$,
			\item $\Sigma = \{openWindow, start, stop, closeWindow\}$,
			\item $\delta = \{(q_0, openWindow, q_1), (q_1, start, q_2), (q_2, stop, q_3), (q_3, closeWindow, q_0)\}$, và
			\item $q_0$ là trạng thái khởi tạo.
		\end{itemize}
		Ta thấy, chuỗi các hành động $openWindow$ $start$ $stop$ là một vết của M, bởi vì tại trạng thái khởi tạo $q_0$, khi sự kiện $openWindow$ xảy ra, hệ thống chuyển sang trạng thái $q_1$, tiếp tục xảy ra sự kiện $start$ hệ thống chuyển sang trạng thái $q_2$, khi xảy ra sự kiện $stop$ hệ thống chuyển sang trạng thái $q_3$. Chuỗi các hành động $openWindow$ $start$ $stop$ chuyển hệ thông từ trạng thái khởi tạo $q_0$ sang trạng thái $q_3 \in Q$ nên chuỗi các hành động  $openWindow$ $start$ $stop$ là một vết của LTS. Tương tự, chuỗi các hành động $openWindow$, $openWindow$ $start$, $openWindow$ $start$ $stop$ $closeWindow$, $openWindow$ $start$ $stop$ $closeWindow$ $openWindow$, ... đều là vết của M.\\
		\textbf{\textit{Định nghĩa 2.5}}: Ngôn ngữ của LTS.\\
		Ngôn ngữ của LTS M kí hiệu là L(M) được định nghĩa như sau:\\
		L(M) = \{$\alpha$ | $\alpha$ là một vết của M\}\\
		\textbf{Ví dụ 2.5}: Ví dụ về ngôn ngữ của LTS.\\
		Với LTS M như ở hình \ref{fig:LTS2}, ngôn ngữ của M là:\\
		L(M) = \{$openWindow, onpenWindow\ start, openWindow \ start \ stop, ...$\}
		\section{Dạng đặc tả sử dụng hàm logic (Bool)}
		\textbf{\textit{Định nghĩa 2.6}}: Hàm logic [1].\\
		B = $\{$T, F$\}$ là miền giá trị logic. Với X là tập hợp các biến logic, một hàm logic $\theta$(X) được định nghĩa $\theta$(X): $\textrm{B}^\textrm{{|X|}} \rightarrow$ B.\\
		\textbf{Ví dụ 2.6}: Ví dụ về hàm logic.\\
		Với X là tập hợp gồm 3 phần tử, X = $\{x, y, z\}$ trong đó $x, y, z \in$ B. Hàm logic $\theta(x, y, z)$ = $x \land y \lor z$ chính là một ánh xạ $\theta$(X): $\textrm{B}^3 \rightarrow$ B.\\
		\textbf{\textit{Định nghĩa 2.7}}: Phép gán [1].\\
		Với X là tập hợp các biến logic, phép gán $\upsilon$ được đinh nghĩa $\upsilon$: X $\rightarrow$ B.\\
		\textbf{Ví dụ 2.7}: Với X là tập hợp gồm 3 phần tử, X = $\{x, y, z\}$ trong đó $x, y, z \in$ B, $\upsilon_1(x)$ = T, $\upsilon_2(x)$ = F, $\upsilon_1(y)$ = T, $\upsilon_2(y)$ = F, $\upsilon_1(z)$ = T và $\upsilon_2(z)$ = F, ... là các phép gán trên tập X.\\
		\textbf{\textit{Định nghĩa 2.8}}: Phép gán hàm [1].\\
		Với $\phi$(X) là hàm một logic trên tập X, $\upsilon$ là một phép gán trên tập X, phép gán hàm kí hiệu $\phi[\upsilon]$ là kết quả thu được khi thay các phần tử $x \in$ X bởi $\upsilon(x)$.
		Với X và $\textrm{X'}$ là các tập biến logic, trong đó $\textrm{X'}$ = \{$x'$ | $x \in$ X \}, $\psi$(X, $\textrm{X'}$) là hàm logic trên hai tập X và $\textrm{X'}$, với $\upsilon(x)$ và $\upsilon'(x')$ lần lượt là các phép gán trên tập X và $\textrm{X'}$, kí hiệu $\psi[\upsilon, \upsilon']$ là kết quả thu được khi thay một cách tương ứng các phần tử $x \in$ X bởi $\upsilon(x)$ và $x' \in$ $\textrm{X'}$ bởi $\upsilon'(x')$.\\
		\textbf{Ví dụ 2.8}: Với X = $\{x\}$, $\textrm{X'} = \{x'\}$ là tập hợp các biến logic, $\phi(x) = \overline{x}$ là một hàm logic trên tập X. Nếu $\upsilon(x)$ = T thì $\phi[\upsilon]$ = F và nếu $\upsilon(x)$ = F thì $\phi[\upsilon]$ = T. Với $\psi(x, x') = x \lor x'$ là một hàm logic trên tập X và $\textrm{X'}$, nếu $\upsilon(x)$ = T, $\upsilon'(x')$ = F thì $\psi[\upsilon, \upsilon']$ = T $\lor$ F = T.\\
		Một cách tổng quát, với n tập các biến logic X, $\textrm{X}_1$, $\textrm{X}_2$, ..., $\textrm{X}_n$ trong đó $\textrm{X}_i$ = $\{x_i$ | $x \in \textrm{X}\}$, $\psi(\textrm{X}, \textrm{X}_1, \textrm{X}_2, ..., \textrm{X}_n)$ là hàm logic tương ứng trên các tập biến logic X, $\textrm{X}_1$, $\textrm{X}_2$, ..., $\textrm{X}_n$, ta kí hiệu $\psi[\upsilon_1, \upsilon_2, ..., \upsilon_n]$ là kết quả thu được khi thay một cách tương ứng các phần tử $x_1 \in \textrm{X}_1$ bởi $\upsilon_1(x_1)$, $x_2 \in \textrm{X}_2$ bởi $\upsilon_2(x_2)$, ... và $x_n \in \textrm{X}_n$ bởi $\upsilon_n(x_n)$.\\
		\textbf{\textit{Định nghĩa 2.9}}: Dạng đặc tả sử dụng hàm logic.\\
		Dạng đặc tả sử dụng hàm logic là một bộ có thứ tự gồm 4 phần tử:\\
		N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'}), \iota(\textrm{X})$ $\rangle$\\
		Trong đó:
		\begin{itemize}
			\item X là tập các biến logic dùng để biểu diễn các trạng thái của hệ thống. X = $\{x_0, x_1, ..., x_n\}$,
			\item E là tập các biến logic dùng để biểu diễn các hành vi của hệ thống. E = $\{e_0, e_1, ..., e_n\}$,
			\item $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$ là hàm logic biểu diễn việc chuyển trạng thái của hệ thống, và
			\item $\iota(\textrm{X})$ là hàm logic dùng để biểu diễn các trạng thái khởi tạo của hệ thống.
		\end{itemize}
		\textbf{Ví dụ 2.9}: Ví dụ về dạng đặc tả sử dụng hàm logic.\\
		Với dạng đặc tả sử dụng hàm logic N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'}), \iota(\textrm{X})$ $\rangle$.\\
		Trong đó:
		\begin{itemize}
			\item X = $\{x_1, x_2\}$, X' = $\{x_5, x_6\}$,
			\item E = $\{x_3, x_4\}$,
			\item $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$ = ($\overline{x}_1 \land \overline{x}_2 \land \overline{x}_3 \land \overline{x}_4 \land x_5 \land \overline{x}_6$) | ($x_1\land\overline{x}_2\land x_3\land \overline{x}_4\land \overline{x}_5 \land x_6$) |
			($\overline{x}_1\land x_2\land\overline{x}_3\land x_4\land \overline{x}_5\land\overline{x}_6$), và
			\item $\iota(\textrm{X}) = \overline{x}_1 \land \overline{x}_2$.
		\end{itemize}
		\textbf{\textit{Định nghĩa 2.10}}: Vết của dạng đặc tả sử dụng hàm logic.\\
		Với dạng đặc tả sử dụng hàm logic N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$, $\iota$(X) $\rangle$, $\upsilon$ là phép gán cho hàm biểu diễn trạng thái trên tập X, $\gamma$ là phép gán cho hàm biểu diễn sự kiện trên tập E, một chuỗi hữu hạn $\xi = \gamma^0\gamma^1...\gamma^n$ được gọi là vết của N khi và chỉ khi tồn tại tập các phép gán $\upsilon^0$, $\upsilon^1$, ..., $\upsilon^{n+1}$, $\gamma^0$, $\gamma^0$, ..., $\gamma^n$ sao cho $\iota[\upsilon^0]$ = T và $\tau[\upsilon^i, \gamma^i, \upsilon^{i+1}]$ = T với 0 $\leq$ i $\leq$ n.\\
		\textbf{Ví dụ 2.10}: Ví dụ về vết của dạng đặc tả sử dụng hàm logic.\\
		Cho dạng đặc tả sử dụng hàm logic N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$, $\iota$(X) $\rangle$.\\
		Trong đó:
		\begin{itemize}
			\item X = $\{x_1, x_2\}$, X' = $\{x_5, x_6\}$,
			\item E = $\{x_3, x_4\}$,
			\item $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$ = $\{$($\overline{x}_1 \land \overline{x}_2) \land (\overline{x}_3 \land \overline{x}_4) \land (x_5 \land \overline{x}_6$) | ($x_1\land\overline{x}_2)\land (x_3\land \overline{x}_4)\land (\overline{x}_5 \land x_6$) | $(\overline{x}_1\land x_2)\land(\overline{x}_3\land x_4)\land (\overline{x}_5\land\overline{x}_6$)$\}$, và
			\item $\iota$(X) = $\overline{x}_1 \land \overline{x}_2$.
		\end{itemize}
		Vì $\iota$(X) = $\overline{x}_1 \land \overline{x}_2$, với $\upsilon^0$ là phép gán trên tập X sao cho $\upsilon^0(x_1)$ = F và $\upsilon^0(x_2)$ = F nên $\iota[\upsilon^0]$ = T $\land$ T = T. Mặt khác, gọi $\upsilon^1$ là phép gán trên tập X sao cho $\upsilon^1(x_5)$ = T, $\upsilon^1(x_6)$ = F, $\gamma^0$ là phép gán trên tập E sao cho $\gamma^0(x_3)$ = F và $\gamma^0(x_4)$ = F. Khi đó, $\tau[\upsilon^0, \gamma^0, \upsilon^1]$ = T nên $\xi = \gamma^0$ là một vết của N.
		Mặt khác, với phép gán $\upsilon^1$, $\gamma^1$,  $\upsilon^2$ sao cho $\upsilon^1(x_1)$ = T, $\upsilon^1(x_2)$ = F, $\gamma^1(x_3)$ = T, $\gamma^1(x_4)$ = F, $\upsilon^2(x_5)$ = F,  $\upsilon^2(x_6)$ = T thì $\tau[\upsilon^1, \gamma^1, \upsilon^2]$ = T. Do đó $\xi = \gamma^0\gamma^1$ cũng là một vết của N. Một cách hoàn toàn tương tự chúng ta có thể tìm được các vết tiếp theo của N.\\
		\textbf{\textit{Định nghĩa 2.11}}: Ngôn ngữ của dạng đặc tả sử dụng hàm logic.\\
		Cho dạng đặc tả sử dụng hàm logic N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$, $\iota$(X) $\rangle$, tập hợp tất cả các vết của N được gọi là ngôn ngữ của N và được kí hiệu là L(N). Ta có: L(N) =  \{ $\xi$ | $\xi$ là một vết của N\}.\\
		\textbf{Ví dụ 2.11}: Với dạng đặc tả sử dụng hàm logic N cho bởi ví dụ 2.10 thì ngôn ngữ của N là L(N) = \{$\overline{x}_3 \land \overline{x}_4$, $\overline{x}_3 \land \overline{x}_4 \land x_3 \land \overline{x}_4$, $\overline{x}_3 \land \overline{x}_4 \land x_3 \land \overline{x}_4 \land \overline{x}_3 \land x_4$, ...\}
		\section{Bảng ánh xạ}
		Bảng ánh xạ (mapping) là một bảng dùng để lưu lại các ánh xạ khi chuyển đổi từ dạng đặc tả sử dụng LTS sang dạng đặc tả sử dụng hàm logic và ngược lại.\\
		Gọi Map là kí hiệu của bảng ánh xạ. Với một LTS M = $\langle$ Q, $\Sigma, \delta, q_{0}$ $\rangle$ trong đó Q = $\textrm{Q}_1 \cup \textrm{Q}_2$ với $\textrm{Q}_1$ là tập các trạng thái đầu vào, $\textrm{Q}_2$ là tập các trạng thái đầu ra và một dạng đặc tả sử dụng hàm logic N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'}), \iota(\textrm{X})$ $\rangle$, trong đó X = $\textrm{X}_1 \cup \textrm{X}_2$ với $\textrm{X}_1$ là tập các biến logic dùng để biểu diễn các trang thái đầu vào của hệ thống, $\textrm{X}_2$ là tập các biến logic biểu diễn các trạng thái đầu ra của hệ thống. Ta định nghĩa:\\
		\[Map = \left\{
		\begin{array}{lr}
			\textrm{Q}_1 \mapsto \textrm{X}_1\\
			\textrm{Q}_2 \mapsto \textrm{X}_2\\
			\Sigma \mapsto E\\
			\delta(q, w, q\textrm{'}) \mapsto \tau(\upsilon, \gamma, \upsilon\textrm{'})\\
		\end{array}
		\right.
		\]
		Trong đó:\\
		\begin{itemize}
			\item $\textrm{Q}_1 \mapsto \textrm{X}_1$ là một song ánh từ tập các trạng thái đầu vào đến tập tập các biến logic dùng để biểu diễn các trạng thái đầu vào của hệ thống,
			\item $\textrm{Q}_2 \mapsto \textrm{X}_2$ là một song ánh từ tập các trạng thái đầu ra đến tập tập các biến logic dùng để biểu diễn các trạng thái đầu ra của hệ thống,
			\item $\Sigma \mapsto E$ là một song ánh từ tập các sự kiện đến tập các biến logic dùng để biểu diễn các sự kiện, và
			\item $\delta(q, w, q\textrm{'}) \mapsto \tau(\upsilon, \gamma, \upsilon\textrm{'})$ là một ánh xạ từ hàm chuyển trạng thái đến tập các hàm logic dùng để biểu diễn việc chuyển trạng thái của hệ thống.
		\end{itemize}
		\textbf{Ví dụ 2.12}: Ví dụ về bảng ánh xạ.\\
		\begin{figure}[h]
			\centering
			\includegraphics[scale=0.5]{LTS2.png}
			\caption{Ví dụ về một LTS.}
			\label{fig:LTS3}
		\end{figure}
		Cho LTS M = $\langle$ $\textrm{Q}, \Sigma, \delta, q_{0}$ $\rangle$ như trên hình \ref{fig:LTS3}, trong đó:
		\begin{itemize}
			\item Q = $\{q_0, q_1, q_2\}$, $\textrm{Q}_1 = \{q_0, q_1, q_2\}$, $\textrm{Q}_2 = \{q_1, q_2, q_0\}$,
			\item $\Sigma = \{send, out, ack\}$,
			\item $\delta = \{(q_0, send, q_1), (q_1, out, q_2), (q_2, ack, q_0)\}$, và
			\item $q_0$ là trạng thái khởi tạo.
		\end{itemize}
		Và dạng đặc tả sử dụng hàm logic N = $\langle$ $\textrm{X}, \textrm{E}, \tau(\textrm{X}, \textrm{E}, \textrm{X'}), \iota(\textrm{X})$ $\rangle$.\\
		Trong đó:
		\begin{itemize}
			\item X = $\{x_1, x_2, x_5, x_6\}$,
			\item E = $\{x_3, x_4\}$,
			\item $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$ = $\{$($\overline{x}_1 \land \overline{x}_2) \land (\overline{x}_3 \land \overline{x}_4) \land (x_5 \land \overline{x}_6$) | ($x_1\land\overline{x}_2)\land (x_3\land \overline{x}_4)\land (\overline{x}_5 \land x_6$) | $(\overline{x}_1\land x_2)\land(\overline{x}_3\land x_4)\land (\overline{x}_5\land\overline{x}_6$)$\}$, và
			\item $\iota$(X) = $\overline{x}_1 \land \overline{x}_2$.
		\end{itemize}
		Khi đó, nếu dạng đặc tả sử dụng LTS M và dạng đặc tả dụng hàm logic N là tương đương. Ta có bảng ánh xạ:
		\begin{table}[!ht]
			\centering
			\renewcommand{\arraystretch}{1.25}
			\begin{tabular}{|c|c|c|c|c|}
				\hline
				$Q_1$ & $q_0$ & $q_1$ & $q_2$\\
				\hline
				$X_1$ & $\overline{x}_1 \land \overline{x}_2$ & $x_1\land\overline{x}_2$&$\overline{x}_1\land x_2$\\
				\hline
			\end{tabular}
			\caption{Thành phần $Q_1 \mapsto X_1$ trong bảng ánh xạ}
		\end{table}
		\begin{table}[!ht]
			\centering
			\renewcommand{\arraystretch}{1.25}
			\begin{tabular}{|c|c|c|c|c|}
				\hline
				$Q_2$ & $q_1$ & $q_2$ & $q_0$\\
				\hline
				$X_2$ & $x_5 \land \overline{x}_6$ & $\overline{x}_5 \land x_6$& $\overline{x}_5\land\overline{x}_6$\\
				\hline
			\end{tabular}
			\caption{Thành phần $Q_2 \mapsto X_2$ trong bảng ánh xạ}
		\end{table}
		\begin{table}[!ht]
			\centering
			\renewcommand{\arraystretch}{1.25}
			\begin{tabular}{|c|c|c|c|}
				\hline
				$\Sigma$ & send & out & ack\\
				\hline
				E & $\overline{x}_3 \land \overline{x}_4$ & $x_3\land \overline{x}_4$ & $\overline{x}_3\land x_4$ \\
				\hline
			\end{tabular}
			\caption{Thành phần $\Sigma \mapsto$ E trong bảng ánh xạ}
		\end{table}
		\begin{table}[!ht]
			\centering
			\renewcommand{\arraystretch}{1.25}
			\begin{tabular}{|c|c|c|c|}
				\hline
				$\delta(q, e, q')$ & $\delta(a, send, b)$ & $\delta(b, out, c)$ & $\delta(c, ack, a)$\\
				\hline
				$\tau(\upsilon, \gamma, \upsilon\textrm{'})$ & $x_0x_1 \land x_2x_3 \land x_4\overline x_5$ & $x_0\overline x_1 \land x_2 \overline x_3 \land x_4 \overline x_5$ & $\overline x_0 x_1 \land \overline x_2 x_3 \land x_4x_5$ \\
				\hline
			\end{tabular}
			\caption{Thành phần $\delta(q, e, q\textrm{'}) \mapsto \tau(\upsilon, \gamma, \upsilon\textrm{'})$ trong bảng ánh xạ}
		\end{table}\\
	\chapter{Phương pháp chuyển đổi}				
		\section{Thuật toán}
		Đầu vào (Input): Một LTS.\\
		Đầu ra (Output): Dạng đặc tả sử dụng hàm logic và bảng ánh xạ.\\
		Thuật toán chia làm 4 bước:
		
		\begin{itemize}
			\item Bước 1: Mã hóa tập các trạng thái đầu vào - Thuật toán 3.1.
			\item Bước 2: Mã hóa tập các trạng thái đầu ra - Thuật toán 3.1.
			\item Bước 3: Mã hóa tập các sự kiện - Thuật toán 3.1.
			\item Bước 4: Mã hóa tập các chuyển trạng thái - Thuật toán 3.2.
		\end{itemize}
		
		\subsection{Thuật toán mã hóa một tập hợp}
		Tập các trạng thái đầu vào, tập các trạng thái đầu ra hay tập các sự kiện gọi chung là một tập hợp. Vì các bước tiến hành mã hóa một tập hợp là giống nhau nên luận văn chỉ trình bày một thuật toán chung. Khi tiến hành mã hóa thì tùy từng mục đích mã hóa tập đầu vào sẽ thay đổi. Cụ thể, nếu chúng ta tiến hành mã hóa tập các trạng thái đầu vào $\textrm{Q}_1$ thì đầu vào cho thuật toán mã hóa sẽ là tập các trạng thái đầu vào $\textrm{Q}_1$, hoặc nếu chúng ta tiến hành mã hõa tập các trạng thái đầu ra $\textrm{Q}_2$ thì đầu vào cho thuật toán mã hóa sẽ là tập các trạng thái đầu ra $\textrm{Q}_2$ và nếu chúng ta tiến hành mã hóa tập các sự kiện $\Sigma$ thì đầu vào cho thuật toán mã hóa sẽ là tập các sự kiện $\Sigma$.\\
		\begin{megaalgorithm}[H]
			\SetKwInOut{Input}{Đầu vào}
			\SetKwInOut{Output}{Đầu ra}
			\SetAlgoLined
			\DontPrintSemicolon
			\Input{Một tập hợp A}
			\Output{Tập hợp các phần tử của tập hợp A đã được mã hóa và bảng ánh xạ}
				
			\For{mỗi phần tử $a_{i}$ trong tập A}{
				Lưu $a_i$ vào trong bảng ánh xạ\;
				$\alpha_i$ = True\;
				k = Thứ tự của $a_i$ trong A\;
				Chuyển k sang số nhị phân với độ dài $[log_2(|A|)] + 1$ bit\;
				\For{mỗi bit trong chuỗi nhị phân biểu diễn k} {
					\uIf{bit = 0} {
						$\alpha_i = \alpha_i \land \overline x_j$\;
					}
					\Else {
						$\alpha_i = \alpha_i \land x_j$
					}
				}
				Lưu $\alpha_i$ vào bảng ánh xạ ứng với vị trí của phần tử $a_i$
			}
			\caption{Thuật toán mã hóa một tập hợp}
		\end{megaalgorithm}
		Với A là tập các phần tử cần mã hóa A = $\{a_0, a_1, ..., a_n\}$. Số biến logic cần dùng để mã hóa tập hợp A là m = $[log_{2}n] + 1$. Gọi X = \{$x_{1}, x_{2}, ..., x_{m}$\} là tập các biến logic dùng để mã hóa các phần tử của A. Mỗi phần tử $a_i$ trong A sẽ được biểu diễn dưới dạng $x_{1}\land x_{2}\land...\land x_{m}$. Xét một phần tử bất kì $a_i$ trong tập A, theo bước (4) ta xác định được thứ tự của $a_i$ trong tập A là k, theo bước (5) thì k sẽ biểu diễn dưới dạng số nhị phân m = $[log_{2}n] + 1$ bit. Theo bước (6)-(12) chúng ta sẽ mã hóa được phần tử $a_i$, kết quả sau khi vòng lặp ở bước (6) kết thúc chúng ta sẽ có được dạng mã hóa của phần tử $a_i$. Thêm vào đó, theo bước (14) dạng biểu diễn của phần tử $a_i$ sẽ được lưu vào trong bảng ánh xạ. Bởi vì, thứ tự của mỗi phần tử trong $a_i$ là duy nhất nên số nhị phân biểu diễn thứ tự của phần tử $a_i$ cũng sẽ là duy nhất, vì thế dạng mã của phần tử $a_i$ là duy nhất. Một cách tương tự cho các phần tử khác trong A, sau khi vòng lặp ở bước (1) kết thúc chúng ta được dạng mã hóa được tất cả các trạng thái của tập A. Thêm vào đó, sau khi mã hóa, các thông tin về các trạng thái và dạng mã hóa tương ứng của từng trạng thái này đều được lưu vào bảng ánh xạ.
		Chúng ta sẽ thấy $\alpha_i = x \overset{n}{\underset{i=1}{\land}} x_i$ là một hàm logic biểu diễn $a_i$ và các phần tử $x_i$ biểu diễn hàm $\alpha_i$ đều thuộc tập $\textrm{X}_i$ với $\textrm{X}_i$ = \{$x_i$ | $x \in$ X\}\\
		\textbf{Độ phức tạp:} Độ phức tạp của thuật toán là O(n), trong đó n là kích thước của tập A cần mã hóa.\\	
				
		\subsection{Thuật toán mã hóa tập các truyển trạng thái}
		\begin{megaalgorithm}[H]
			\SetKwInOut{Input}{Đầu vào}
			\SetKwInOut{Output}{Đầu ra}
			\SetAlgoLined
			\DontPrintSemicolon
			\Input{Tập hợp các chuyển trạng thái của LTS.}
			\Output{Hàm chuyển trạng thái $\tau(\textrm{X}, \textrm{E}, \textrm{X'})$}
				
			\For{mỗi chuyển trạng thái được biểu diễn $\delta(q, w, q')$}{
				Lấy dạng biểu diễn $\alpha_i$ của $q$ từ bảng ánh xạ của tập các trạng thái đầu vào\;
				Lấy dạng biểu diễn $e_i$ của $w_i$ từ bảng ánh xạ của tập các sự kiện\;
				Lấy dạng biểu diễn $\alpha_{i+1}$ của $q'$ từ bảng ánh xạ của tập các trạng thái đầu ra\;
				$\tau = \overset{n}{\underset{i=1}{\lor}} \{\alpha_i \land e_i \land \alpha_{i+1}\}$
			}
			\Return $\tau$
				
			\caption{Mã hóa tập các chuyển trạng thái}
		\end{megaalgorithm}
		
		Một chuyển trạng thái được biểu diễn là một bộ ba (q, w, q'), nên để mã hóa cho mỗi chuyển trạng thái, chúng ta cần tìm dạng mã hóa cho từng thành phần q, $w$ và q'. Dựa theo thuật toán 3.1, chúng ta đã có được bảng ánh xạ lưu thông tin về các trạng thái và dạng mã hóa tương ứng, thông tin về các sự kiện và dạng mã hóa tương ứng. Xét một chuyển trạng thái ($\textrm{q}_1$, $w_i$, $\textrm{q}_{i+1}$') Theo bước (2) $q_{i}$ sẽ tương ứng với $x_i$ trong bảng ánh xạ của tập các trạng thái đầu vào. Theo bước (3) sự kiện $w_i$ sẽ tương ứng với $e_i$ trong bảng ánh xạ của tập các sự kiện. Theo bước (4) trạng thái $q_{i+1}$ sẽ tương ứng với $x_{i+1}$ trong bảng ánh xạ của tập các trạng thái đầu ra. Sau bước (5), chuyển trạng thái ($\textrm{q}_1$, $w_i$, $\textrm{q}_{i+1}$') sẽ được biểu diễn dưới dạng $\alpha_{i} \land e_i \land \alpha_{i+1}$.\\
		\textbf{Độ phức tạp:} Độ phức tạp của thuật toán là O(n), trong đó n là kích thước của tập hợp các chuyển trạng thái cần mã hóa.
		\section{Chứng minh}
		Với thuật toán mã hóa đưa ra ở chương phía trước chúng ta hoàn toàn có thể chuyển đổi một dạng đặc tả sử dụng LTS sang dạng đặc tả sử dụng hàm logic và ngược lại từ dạng đặc tả sử dụng hàm logic kết hợp với bảng ánh xạ để chuyển đổi sang dạng đặc tả sử dụng LTS. Tuy nhiên, hai dạng đặc tả này sau khi chuyển đổi liệu có tương đương với nhau?
		Để chứng minh ngôn ngữ của dạng đặc tả được biểu diễn bằng LTS tương đương với ngôn ngữ của dạng đặc tả sử dụng hàm logic, chúng ta cần chứng minh 2 mệnh đề:
		\begin{itemize}
			\item Mệnh đề 1: Ngôn ngữ của dạng đặc tả hệ thống biểu diễn bằng LTS sau khi chuyển đổi sang dạng đặc tả biểu diễn bằng hàm logic được đoán nhận bởi dạng đặc tả sử dụng hàm logic. (1)\\
			\item Mệnh đề 2: Ngôn ngữ của dạng đặc tả sử dụng hàm logic sau khi chuyển sang dạng đặc tả biểu diễn bằng LTS được đoán nhận bởi LTS.
		\end{itemize}
		\textbf{Chứng minh mệnh đề 1}:\\
		Với một LTS M = <Q, $\Sigma, \delta, \textrm{q}_0>$, L(M) là ngôn ngữ của của M và một dạng đặc tả sử dụng hàm logic N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'}), \iota(\textrm{X})$ $\rangle$, L(N) là ngôn ngữ của N, N được chuyển đổi từ M.
		Với $\alpha = w_0w_1...w_n$ là vết của LTS M, áp dụng thuật toán 3.1 ta thu được $\xi = \gamma^0\gamma^1...\gamma^n$, ta cần chứng minh $\xi$ được đoán nhận bởi L(N). Thật vậy, xét $q_0$ là trạng thái khởi tạo của M, áp dụng thuật toán 3.1, chúng ta sẽ mã hóa $q_0$ thành $\alpha_0$. Vì $\alpha_0$ là một hàm logic nên tồn tại một phép gán $\upsilon^0$ cho hàm $\alpha_0$ trên tập X sao cho $\iota[\upsilon^0]$ = T. (*)\\
		Mặt khác, gọi $\delta(q_i, w_i, q_{i+1})$ là một chuyển trạng thái bất kì trong tập các chuyển trạng thái của LTS, áp dụng thuật toán 3.2, $\delta(q_i, w_i, q_{i+1})$ sẽ được mã hóa thành $\tau(\alpha_i, e_i,  \alpha_{i+1})$. Vì $\alpha_i, e_i, \alpha_{i+1}$ là hội của các biến logic nên tồn tại các phép gán $\upsilon^i$ cho hàm $\alpha_i$ trên tập $\textrm{X}$, $\upsilon^{i+1}$ cho hàm $\alpha_{i+1}$ trên tập $\textrm{X'}$, $\gamma^i$ là phép gán cho hàm $e_i$ trên tập $\textrm{E}$ sao cho $\upsilon^i$ = T, $\upsilon^{i+1}$ = T, $\gamma^i$ = T để $\tau[\upsilon^i, \gamma^i, \upsilon^{i+1}]$ = T (**). Từ (*), (**) và định nghĩa 2.10, $\xi = \gamma^0\gamma^1...\gamma^n$ là một vết của N hay $\xi \in$ L(N).\\
		\textbf{Chứng minh mệnh đề 2}:\\
		Với một LTS M = <Q, $\Sigma, \delta, \textrm{q}_0>$, L(M) là ngôn ngữ của của M và một dạng đặc tả sử dụng hàm logic N = $\langle$ X, E, $\tau(\textrm{X}, \textrm{E}, \textrm{X'}), \iota(\textrm{X})$ $\rangle$, L(N) là ngôn ngữ của N và N được chuyển đổi từ M.
		Gọi Map là bảng ánh xạ lưu các ánh xạ khi chuyển đổi từ M sang N. Gọi $\alpha_i$ là dạng mã hóa của trạng thái $q_i$. Gọi $\xi = \gamma^0\gamma^1...\gamma^n$ là một vết của N. 
		Trong đó, $\gamma^i$ là phép gán cho hàm $e^i$ biểu diễn hành vi thứ i của hệ thống. Theo định nghĩa vết của dạng đặc tả đặc tả sử dụng hàm logic 2.10 vì $\xi = \gamma^0\gamma^1...\gamma^n$ là một vết của N nên tồn tại các phép gán $\upsilon^0$, $\upsilon^1$, ..., $\upsilon^{n+1}$, $\gamma^0$, $\gamma^1$, ..., $\gamma^n$ sao cho $\iota[\upsilon^0]$ = T và $\tau[\upsilon^i, \gamma^i, \upsilon^{i+1}]$ = T với $\forall i$: $0 \leq i \leq n$. Vì $\alpha_0[\upsilon^0] =$ T nên $q_0$ là trạng thái khởi tạo của M. Thêm vào đó, vì $\tau[\upsilon^i, \gamma^i, \upsilon^{i+1}]$ = T nên dựa vào bảng ánh xạ Map ta thu được các hàm chuyển trạng thái $\delta(q_i, w_i, q_{i+1})$ tương ứng. Vì $0 \leq i \leq n$ nên ta có chuỗi các sự kiện $\sigma = w_0w_1...w_i$ là một vết của M. Với $q_0$ là trạng thái khởi tạo, sau khi sự kiện $w_0$ xảy ra hệ thống chuyển sang trạng thái $q_1$ (do sự tồn tại của chuyển trạng thái $\delta(q_0, w_0, q_1)$), từ trạng thái $q_1$ khi xảy ra sự kiện $w_1$ hệ thống chuyển sang trạng thái $q_2$ (do sự tồn tại của chuyển trạng thái $\sigma(q_1, w_1, q_2)$), một cách tương tự với các sự kiện từ $w_2$ đến $w_{i-1}$, sau khi sự kiện $w_{i-1}$ xảy ra hệ thống chuyển sang trạng thái $q_i$, khi sự kiện $w_i$ xảy ra, do sự tồn tại của chuyển trạng thái $\sigma(q_i, w_i, q_{i+1})$ nên hệ thống chuyển sang trạng thái $q_{i+1}$. Vì thế, với $\forall i$: $0 \leq i \leq n$, tồn tại trạng thái $q_i \in$ Q sao cho $q_0 \overset{\sigma}{\longrightarrow} q_{i}$ nên theo định nghĩa 2.4, $\sigma = w_0w_1...w_n$ là một vết của M.
	\chapter{Ví dụ về việc chuyển đổi giữa các dạng đặc tả}
	
	\end{flushleft}
\begin{thebibliography}{9}
	\bibitem{latexcompanion} 
	Yu-Fang Chen, Edmund M. Clarke, Azadeh Farzan, Ming-Hsien Tsai,
	Yih-Kuen Tsay, and Bow-Yaw Wang, \textit{Automated Assume-Guarantee Reasoning
		through Implicit Learning}. 
	Addison-Wesley, Reading, Massachusetts, 1993.
	\bibitem{latexcompanion1}
	Pham Ngoc Hung, \textit{Assume-Guarantee Verification of Evolving Component-Based Software}.
	Japan Advanced Institute of Science and Technology in partial fulfillment of the requirements for the degree of Doctor of Philosophy, September, 2009.
	\bibitem{latexcompanion2}
	P. N. Hung, N. V.  Ha, T. Aoki and T. Katayama, \textit{On Optimization of Minimized Assumption Generation Method for Component-based Software Verification}
	IEICE Trans. on Fundamentals, Special Issue on Software Reliability Engineering, Vol. E95-A, No.9, pp. 1451-1460, Sep. 2012.
\end{thebibliography}
\end{document}